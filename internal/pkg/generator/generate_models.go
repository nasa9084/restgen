package generator

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	openapi "github.com/nasa9084/go-openapi"
	"github.com/nasa9084/restgen/internal/pkg/utils"
	"golang.org/x/tools/imports"
)

// GenerateSchemaTypes generates Go's type definitions from .components.schemas.
// The generated source is formatted by goimports.
func GenerateSchemaTypes(spec *openapi.Document) ([]byte, error) {
	components := spec.Components
	if components == nil {
		return nil, nil
	}
	schemas := components.Schemas
	if schemas == nil {
		return nil, nil
	}
	var schemaNames []string
	for name := range schemas {
		schemaNames = append(schemaNames, name)
	}
	sort.Strings(schemaNames)

	var buf bytes.Buffer
	buf.WriteString("package models")
	buf.WriteString("\n// code generated by restgen. DO NOT EDIT.")
	for _, name := range schemaNames {
		schema := schemas[name]
		t, err := generateSchemaType(name, schema)
		if err != nil {
			return nil, err
		}
		buf.Write(t)
	}
	src, err := imports.Process("", buf.Bytes(), &imports.Options{Fragment: true, Comments: true})
	if err != nil {
		return nil, err
	}
	return src, nil
}

func generateSchemaType(name string, schema *openapi.Schema) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString("\n")
	if schema.Description != "" {
		for _, line := range strings.Split(schema.Description, "\n") {
			fmt.Fprintf(&buf, "\n// %s", line)
		}
	}
	fmt.Fprintf(&buf, "\ntype %s %s", name, (*OpenAPISchema)(schema).GoType())
	return buf.Bytes(), nil
}

// GenerateResponseTypes generates Go's type definitions from .components.responses.
// The generated source is formatted by goimports.
func GenerateResponseTypes(spec *openapi.Document) ([]byte, error) {
	components := spec.Components
	if components == nil {
		return nil, nil
	}
	responses := components.Responses
	if responses == nil {
		return nil, nil
	}
	var responseNames []string
	for name := range responses {
		responseNames = append(responseNames, name)
	}
	sort.Strings(responseNames)

	var buf bytes.Buffer
	buf.WriteString("package models")
	buf.WriteString("\n// code generated by restgen. DO NOT EDIT.")
	for _, name := range responseNames {
		response := responses[name]
		t, err := generateResponseType(name, response)
		if err != nil {
			return nil, err
		}
		buf.Write(t)
	}
	src, err := imports.Process("", buf.Bytes(), &imports.Options{Fragment: true, Comments: true})
	if err != nil {
		return nil, err
	}
	return src, nil
}

func generateResponseType(name string, response *openapi.Response) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString("\n")
	for _, line := range strings.Split(response.Description, "\n") {
		fmt.Fprintf(&buf, "\n// %s", line)
	}
	fmt.Fprintf(&buf, "\ntype %s", name)
	content := response.Content
	if content == nil {
		return nil, fmt.Errorf(".components.responses[%s].content is nil", name)
	}
	mediaType, ok := content["application/json"]
	if !ok {
		return nil, fmt.Errorf(".components.responses[%s].content[application/json] is nil", name)
	}
	buf.WriteString(" ")
	buf.WriteString((*OpenAPISchema)(mediaType.Schema).GoType())
	return buf.Bytes(), nil
}

// GenerateRequestTypes generates Go's type definitions from .components.requestBodies.
// The generated source is formatted by goimports.
func GenerateRequestBodyTypes(spec *openapi.Document) ([]byte, error) {
	components := spec.Components
	if components == nil {
		return nil, nil
	}
	requestBodies := components.RequestBodies
	if requestBodies == nil {
		return nil, nil
	}
	var requestNames []string
	for name := range requestBodies {
		requestNames = append(requestNames, name)
	}
	sort.Strings(requestNames)
	var buf bytes.Buffer
	buf.WriteString("package models")
	buf.WriteString("\n// code generated by restgen. DO NOT EDIT.")
	for _, name := range requestNames {
		requestBody := requestBodies[name]
		t, err := generateRequestBodyType(name, requestBody)
		if err != nil {
			return nil, err
		}
		buf.Write(t)
	}
	src, err := imports.Process("", buf.Bytes(), &imports.Options{Fragment: true, Comments: true})
	if err != nil {
		return nil, err
	}
	return src, nil
}

func generateRequestBodyType(name string, requestBody *openapi.RequestBody) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString("\n")
	if requestBody.Description != "" {
		for _, line := range strings.Split(requestBody.Description, "\n") {
			fmt.Fprintf(&buf, "\n// %s", line)
		}
	}
	if strings.HasSuffix(name, "Request") {
		name += "Body"
	}
	if !strings.HasSuffix(name, "RequestBody") {
		name += "RequestBody"
	}
	fmt.Fprintf(&buf, "\ntype %s", name)
	// requestBody.Content is required parameter and checked by Validate().
	mediaType, ok := requestBody.Content["application/json"]
	if !ok {
		return nil, fmt.Errorf(".components.requestBodies[%s].content[application/json] is nil", name)
	}
	buf.WriteString(" ")
	buf.WriteString((*OpenAPISchema)(mediaType.Schema).GoType())
	return buf.Bytes(), nil
}

func GenerateRequestTypes(spec *openapi.Document) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString("package models")
	buf.WriteString("\n// code generated by restgen. DO NOT EDIT.")
	for _, path := range utils.SortedPaths(spec.Paths) {
		pathItem := spec.Paths[path]
		for _, method := range utils.SortedMethods(pathItem) {
			op := pathItem.GetOperationByMethod(method)
			buf.WriteString("\n\ntype ")
			buf.WriteString(op.OperationID)
			buf.WriteString("Request struct {")
			params, err := generateRequestParameters(spec, path, method, op.Parameters)
			if err != nil {
				return nil, err
			}
			buf.Write(params)
			if op.RequestBody != nil {
				buf.WriteString("\nBody ")
				if op.RequestBody.Ref != "" {
					typeName := utils.NameFromRef(op.RequestBody.Ref)
					if strings.HasSuffix(typeName, "Request") {
						typeName += "Body"
					}
					buf.WriteString(typeName)
				} else {
					mediaType, ok := op.RequestBody.Content["application/json"]
					if !ok {
						return nil, fmt.Errorf(".paths[%s].%s.requestBody.content[application/json] is nil", path, strings.ToLower(method))
					}
					buf.WriteString((*OpenAPISchema)(mediaType.Schema).GoType())
				}
			}
			buf.WriteString("\n}")
		}
	}
	src, err := imports.Process("", buf.Bytes(), &imports.Options{Fragment: true, Comments: true})
	if err != nil {
		return nil, err
	}
	return src, nil
}

func generateRequestParameters(spec *openapi.Document, path, method string, parameters []*openapi.Parameter) ([]byte, error) {
	params := map[string]*bytes.Buffer{}
	for i, param := range parameters {
		if param.Ref != "" {
			var err error
			param, err = openapi.ResolveParameter(spec, param.Ref)
			if err != nil {
				return nil, err
			}
		}
		var name string
		switch param.In {
		case "query":
			name = "Query"
		case "header":
			name = "Header"
		case "path":
			name = "PathArgs"
		case "cookie":
			name = "Cookie"
		}
		pbuf, ok := params[string(param.In)]
		if !ok {
			pbuf = &bytes.Buffer{}
			pbuf.WriteString("\n")
			pbuf.WriteString(name)
			pbuf.WriteString(" struct {")
			params[string(param.In)] = pbuf
		}
		pbuf.WriteString("\n")
		pbuf.WriteString(param.Name)
		pbuf.WriteString(" ")
		if param.Schema == nil {
			return nil, fmt.Errorf(".paths[%s].%s.parameters[%d].Schema is nil", path, strings.ToLower(method), i)
		}
		pbuf.WriteString((*OpenAPISchema)(param.Schema).GoType())
	}
	var buf bytes.Buffer
	for _, key := range []string{"query", "header", "path", "cookie"} {
		pbuf, ok := params[key]
		if ok && pbuf.Len() != 0 {
			pbuf.WriteString("\n}")
			buf.Write(pbuf.Bytes())
		}
	}
	return buf.Bytes(), nil
}
